<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SUIKA-GAME</title>
    <style>
        body {
            margin: 0;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            background-color: #f0f0f0;
            font-family: 'Arial', sans-serif;
        }
        #game-container {
            position: relative;
            border: 2px solid #333;
            background-color: #fff;
            box-shadow: 0 4px 8px rgba(0,0,0,0.1);
            display: none; /* Hidden by default */
        }
        #ui-container {
            position: absolute;
            top: 10px;
            left: 10px;
            right: 10px;
            display: flex;
            justify-content: space-between;
            font-size: 24px;
            color: #333;
            pointer-events: none;
        }
        .screen {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: rgba(0, 0, 0, 0.7);
            color: white;
            display: none; /* Hidden by default */
            flex-direction: column;
            justify-content: center;
            align-items: center;
            text-align: center;
        }
        .screen h2 {
            margin: 0;
            font-size: 48px;
        }
        .screen p {
            font-size: 24px;
        }
        .menu-button {
            margin-top: 20px;
            padding: 15px 30px;
            font-size: 24px;
            cursor: pointer;
            border: none;
            border-radius: 5px;
            background-color: #4CAF50;
            color: white;
            width: 250px;
        }
        #main-menu-screen {
            display: flex; /* Visible by default */
            position: static; /* Not an overlay */
            background-color: #fff;
            color: #333;
        }
    </style>
</head>
<body>
    <div id="main-menu-screen" class="screen">
        <h2>SUIKA-GAME</h2>
        <button id="endless-mode-button" class="menu-button">通常モード</button>
        <button id="clear-mode-button" class="menu-button">タイムアタック</button>
        <button id="hospitality-mode-button" class="menu-button" style="display: none;">接待モード</button>
        <button id="abuse-mode-button" class="menu-button" style="display: none;">虐待モード</button>
    </div>

    <div id="game-container">
        <div id="ui-container">
            <div id="score">Score: 0</div>
            <div id="timer">Time: 00:00.0</div>
        </div>
        <div id="game-over-screen" class="screen">
            <h2>Game Over</h2>
            <p id="final-score"></p>
            <button id="back-to-menu-gameover" class="menu-button">メニューに戻る</button>
        </div>
        <div id="win-screen" class="screen">
            <h2>クリア！</h2>
            <p id="win-score"></p>
            <button id="back-to-menu-win" class="menu-button">メニューに戻る</button>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/matter-js/0.19.0/matter.min.js"></script>
    <script>
        document.addEventListener('DOMContentLoaded', () => {
            // --- Matter.js setup ---
            const { Engine, Render, Runner, World, Bodies, Events, Body } = Matter;

            // --- DOM Elements ---
            const mainMenuScreen = document.getElementById('main-menu-screen');
            const gameContainer = document.getElementById('game-container');
            const scoreElement = document.getElementById('score');
            const timerElement = document.getElementById('timer');
            const gameOverScreen = document.getElementById('game-over-screen');
            const winScreen = document.getElementById('win-screen');
            const finalScoreElement = document.getElementById('final-score');
            const winScoreElement = document.getElementById('win-score');
            
            // Buttons
            const endlessModeButton = document.getElementById('endless-mode-button');
            const clearModeButton = document.getElementById('clear-mode-button');
            const hospitalityModeButton = document.getElementById('hospitality-mode-button');
            const abuseModeButton = document.getElementById('abuse-mode-button');
            const backToMenuGameOver = document.getElementById('back-to-menu-gameover');
            const backToMenuWin = document.getElementById('back-to-menu-win');

            // --- Game Constants ---
            const WIDTH = 400;
            const HEIGHT = 600;
            const DANGER_ZONE_Y = 80;

            // --- Game State Variables ---
            let engine, render, runner;
            let currentFruit = null;
            let score = 0;
            let isGameOver = false;
            let gameMode = 'endless';
            let gameStartTime = 0;
            let timerInterval = null;
            let collisionCooldown = new Set();
            let fruitInDangerZone = new Map();
            let menuClickCount = 0;
            let fruitsDropped = 0;

            // --- Fruit Definitions ---
            const FRUITS = [
                { level: 0, radius: 15, color: '#ff5757', score: 1 },  // Cherry
                { level: 1, radius: 20, color: '#ffb357', score: 3 },  // Orange
                { level: 2, radius: 28, color: '#fff057', score: 6 },  // Lemon
                { level: 3, radius: 35, color: '#b3ff57', score: 10 }, // Lime
                { level: 4, radius: 45, color: '#57ffb3', score: 15 }, // Melon
                { level: 5, radius: 55, color: '#57b3ff', score: 21 }, // Blueberry
                { level: 6, radius: 70, color: '#b357ff', score: 28 }, // Grape
                { level: 7, radius: 85, color: '#ff57b3', score: 36 }, // Watermelon
            ];
            const MAX_LEVEL = FRUITS.length - 1;

            // --- Core Functions ---

            function setupMainMenu() {
                mainMenuScreen.style.display = 'flex';
                gameContainer.style.display = 'none';
                menuClickCount = 0;
                
                mainMenuScreen.onclick = (e) => {
                    // prevent clicks on buttons from counting
                    if (e.target.id === 'main-menu-screen') {
                        menuClickCount++;
                        if (menuClickCount >= 10) {
                            hospitalityModeButton.style.display = 'block';
                            abuseModeButton.style.display = 'block';
                        }
                    }
                };

                endlessModeButton.onclick = () => startGame('endless');
                clearModeButton.onclick = () => startGame('time-attack');
                hospitalityModeButton.onclick = () => startGame('hospitality');
                abuseModeButton.onclick = () => startGame('abuse');
                backToMenuGameOver.onclick = returnToMenu;
                backToMenuWin.onclick = returnToMenu;
            }

            function startGame(mode) {
                gameMode = mode;
                mainMenuScreen.style.display = 'none';
                gameContainer.style.display = 'block';

                // Reset mode-specific UI
                scoreElement.style.display = 'none';
                timerElement.style.display = 'none';

                if (gameMode === 'time-attack') {
                    timerElement.style.display = 'block';
                    gameStartTime = Date.now();
                    timerInterval = setInterval(updateTimer, 100);
                } else {
                    scoreElement.style.display = 'block';
                }

                initGame();
            }

            function returnToMenu() {
                if (timerInterval) clearInterval(timerInterval);
                if (engine) {
                    World.clear(engine.world);
                    Engine.clear(engine);
                    Render.stop(render);
                    Runner.stop(runner);
                    if (render.canvas) render.canvas.remove();
                    render.textures = {};
                }
                gameOverScreen.style.display = 'none';
                winScreen.style.display = 'none';
                setupMainMenu();
            }

            function initGame() {
                score = 0;
                isGameOver = false;
                fruitsDropped = 0;
                collisionCooldown.clear();
                fruitInDangerZone.clear();
                updateScore(0);

                engine = Engine.create();
                engine.world.gravity.y = 0.9;

                render = Render.create({
                    element: gameContainer,
                    engine: engine,
                    options: { width: WIDTH, height: HEIGHT, wireframes: false, background: '#ffffff' }
                });

                runner = Runner.create();
                Runner.run(runner, engine);
                Render.run(render);

                const ground = Bodies.rectangle(WIDTH / 2, HEIGHT, WIDTH, 30, { isStatic: true, label: 'ground' });
                const leftWall = Bodies.rectangle(0, HEIGHT / 2, 30, HEIGHT, { isStatic: true, label: 'wall' });
                const rightWall = Bodies.rectangle(WIDTH, HEIGHT / 2, 30, HEIGHT, { isStatic: true, label: 'wall' });
                const gameOverSensor = Bodies.rectangle(WIDTH / 2, DANGER_ZONE_Y / 2, WIDTH, DANGER_ZONE_Y, {
                    isStatic: true, isSensor: true, label: 'gameOverSensor',
                    render: { fillStyle: 'rgba(255, 0, 0, 0.1)' }
                });

                World.add(engine.world, [ground, leftWall, rightWall, gameOverSensor]);
                addCurrentFruit();
                setupGameEventListeners();
            }
            
            function setupGameEventListeners() {
                const handleMouseMove = (event) => {
                    if (currentFruit && !isGameOver) {
                        const rect = gameContainer.getBoundingClientRect();
                        let x = event.clientX - rect.left;
                        const radius = FRUITS[currentFruit.level].radius;
                        x = Math.max(radius + 15, Math.min(x, WIDTH - radius - 15));
                        Body.setPosition(currentFruit, { x: x, y: currentFruit.position.y });
                    }
                };
                const handleMouseClick = (event) => {
                    if (currentFruit && !isGameOver) {
                        const rect = gameContainer.getBoundingClientRect();
                        const x = event.clientX - rect.left;
                        dropCurrentFruit(x);
                    }
                };
                gameContainer.addEventListener('mousemove', handleMouseMove);
                gameContainer.addEventListener('click', handleMouseClick);
                Events.on(engine, 'collisionStart', (event) => {
                    if (isGameOver) return;
                    event.pairs.forEach(pair => {
                        const { bodyA, bodyB } = pair;
                        if (bodyA.label === 'fruit' && bodyB.label === 'fruit' && bodyA.level === bodyB.level) {
                            handleFruitMerge(bodyA, bodyB);
                        }
                        handleGameOverCollision(pair, 'start');
                    });
                });
                Events.on(engine, 'collisionEnd', (event) => {
                    if (isGameOver) return;
                    event.pairs.forEach(pair => handleGameOverCollision(pair, 'end'));
                });
            }

            function handleFruitMerge(bodyA, bodyB) {
                const fruitLevel = bodyA.level;
                const idA = bodyA.id;
                const idB = bodyB.id;
                if (collisionCooldown.has(idA) || collisionCooldown.has(idB)) return;

                if (fruitLevel === MAX_LEVEL) {
                    collisionCooldown.add(idA);
                    collisionCooldown.add(idB);
                    World.remove(engine.world, [bodyA, bodyB]);
                    updateScore(100);
                    if (gameMode === 'time-attack') {
                        triggerGameWin();
                    }
                    setTimeout(() => {
                        collisionCooldown.delete(idA);
                        collisionCooldown.delete(idB);
                    }, 100);
                } else {
                    collisionCooldown.add(idA);
                    collisionCooldown.add(idB);
                    const newLevel = fruitLevel + 1;
                    const midX = (bodyA.position.x + bodyB.position.x) / 2;
                    const midY = (bodyA.position.y + bodyB.position.y) / 2;
                    const newFruit = createFruit(midX, midY, newLevel);
                    World.remove(engine.world, [bodyA, bodyB]);
                    World.add(engine.world, newFruit);
                    updateScore(FRUITS[fruitLevel].score);
                    setTimeout(() => {
                        collisionCooldown.delete(idA);
                        collisionCooldown.delete(idB);
                    }, 100);
                }
            }

            function handleGameOverCollision(pair, type) {
                const { bodyA, bodyB } = pair;
                let fruitBody = null;
                if (bodyA.label === 'gameOverSensor' && bodyB.label === 'fruit') fruitBody = bodyB;
                else if (bodyB.label === 'gameOverSensor' && bodyA.label === 'fruit') fruitBody = bodyA;
                if (!fruitBody || fruitBody === currentFruit) return;
                if (type === 'start') {
                    if (!fruitInDangerZone.has(fruitBody.id)) {
                        const timer = setTimeout(() => {
                            if (fruitBody.speed < 0.1 && fruitBody.angularSpeed < 0.1) triggerGameOver();
                        }, 1500);
                        fruitInDangerZone.set(fruitBody.id, timer);
                    }
                } else {
                    if (fruitInDangerZone.has(fruitBody.id)) {
                        clearTimeout(fruitInDangerZone.get(fruitBody.id));
                        fruitInDangerZone.delete(fruitBody.id);
                    }
                }
            }

            function createFruit(x, y, level) {
                const fruitDef = FRUITS[level];
                const fruit = Bodies.circle(x, y, fruitDef.radius, {
                    label: 'fruit', restitution: 0.3, friction: 0.5,
                    render: { fillStyle: fruitDef.color, strokeStyle: '#333', lineWidth: 2 }
                });
                fruit.level = level;
                return fruit;
            }

            function addCurrentFruit() {
                if (isGameOver) return;
                
                let spawnLevel = 0;
                switch (gameMode) {
                    case 'hospitality':
                        if (fruitsDropped < 5) spawnLevel = Math.floor(Math.random() * 2); // 0-1
                        else if (fruitsDropped < 10) spawnLevel = Math.floor(Math.random() * 2) + 1; // 1-2
                        else if (fruitsDropped < 15) spawnLevel = Math.floor(Math.random() * 2) + 2; // 2-3
                        else if (fruitsDropped < 25) spawnLevel = Math.floor(Math.random() * 2) + 3; // 3-4
                        else if (fruitsDropped < 35) spawnLevel = Math.floor(Math.random() * 2) + 4; // 4-5
                        else if (fruitsDropped < 45) spawnLevel = Math.floor(Math.random() * 2) + 5; // 5-6
                        else spawnLevel = MAX_LEVEL;
                        break;
                    case 'abuse':
                        const abuseSpawnPool = [0, 0, 0, 2, 4]; // More red, yellow, blue-green
                        spawnLevel = abuseSpawnPool[Math.floor(Math.random() * abuseSpawnPool.length)];
                        break;
                    case 'endless':
                    case 'time-attack':
                    default:
                        spawnLevel = Math.floor(Math.random() * 5); // Original spawn
                        break;
                }

                currentFruit = createFruit(WIDTH / 2, 40, spawnLevel);
                currentFruit.isStatic = true;
                World.add(engine.world, currentFruit);
            }

            function dropCurrentFruit(x) {
                if (!currentFruit || isGameOver) return;
                fruitsDropped++;
                Body.setStatic(currentFruit, false);
                Body.setPosition(currentFruit, { x: x, y: currentFruit.position.y });
                currentFruit = null;
                setTimeout(addCurrentFruit, 600);
            }

            function updateScore(points) {
                score += points;
                scoreElement.textContent = `Score: ${score}`;
            }

            function updateTimer() {
                if (isGameOver || !gameStartTime) return;
                const elapsed = Date.now() - gameStartTime;
                timerElement.textContent = `Time: ${formatTime(elapsed)}`;
            }

            function formatTime(ms) {
                const minutes = Math.floor(ms / 60000);
                const seconds = Math.floor((ms % 60000) / 1000);
                const milliseconds = Math.floor((ms % 1000) / 100);
                return `${String(minutes).padStart(2, '0')}:${String(seconds).padStart(2, '0')}.${milliseconds}`;
            }

            function triggerGameOver() {
                if (isGameOver) return;
                isGameOver = true;
                if (timerInterval) clearInterval(timerInterval);
                Runner.stop(runner);
                finalScoreElement.textContent = (gameMode === 'time-attack') ? `モード失敗` : `最終スコア: ${score}`;
                gameOverScreen.style.display = 'flex';
            }

            function triggerGameWin() {
                if (isGameOver) return;
                isGameOver = true;
                if (timerInterval) clearInterval(timerInterval);
                Runner.stop(runner);
                const finalTime = Date.now() - gameStartTime;
                winScoreElement.textContent = `クリアタイム: ${formatTime(finalTime)}`;
                winScreen.style.display = 'flex';
            }
            
            // --- Initial Setup ---
            setupMainMenu();
        });
    </script>
</body>
</html>
